package dev.inkremental.meta.gradle

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import dev.inkremental.meta.model.*
import kotlinx.serialization.json.Json
import org.gradle.api.DefaultTask
import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.getByType
import java.io.File
import java.lang.reflect.*
import java.net.URL
import java.net.URLClassLoader
import java.util.*
import java.util.jar.JarFile
import kotlin.reflect.KFunction
import kotlin.reflect.KTypeParameter
import kotlin.reflect.full.*
import kotlin.reflect.jvm.kotlinFunction

abstract class GenerateDslTask : DefaultTask() {
    @get:Input abstract var modelFile: File
    @get:OutputDirectory abstract var outputDirectory: File

    @TaskAction
    fun renderModel() {
        val json = Json {
            encodeDefaults = false
            prettyPrint = false
            serialModule = ModelModule
        }
        val inputStr = modelFile.readText()
        val model = json.parse(ModuleModel.serializer(), inputStr)
        model.views.forEach(ViewModel::backlinkAttrs)

        val fileSpec = FileSpec.builder(model.packageName, model.name)

        val setterBody = buildCodeBlock {
            beginControlFlow("return when (name)")
            model.views
                .flatMap { it.attrs }
                .groupBy { it.name }
                .mapValues { (_, it) -> it.sortedBy { it.type.name } }
                .forEach { (name, attrs) ->
                    val filtered = attrs.filter { a ->
                        attrs.none { b ->
                            // TODO what?
                            a != b && a.type == b.type && a.owner.isAssignableFrom(b.owner)
                        }
                    }

                    beginControlFlow("%S -> when", name)
                    filtered.map {
                        if (it.isListener) {
                            it.buildListener()
                        } else {
                            it.buildSetter()
                        }
                    }.forEach { add(it) }

                    add("else -> false\n")
                    endControlFlow()
                }
            add("else -> false\n")
            endControlFlow()
        }
        val setterFunction = FunSpec.builder("set")
            .addParameter("v", VIEW)
            .addParameter("name", STRING)
            .addParameter("arg", ANY_N)
            .addParameter("old", ANY_N)
            .returns(BOOLEAN)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .addCode(setterBody)
            .build()

        val setterObject = TypeSpec.objectBuilder(ClassName(PACKAGE, "${model.name}Setter"))
            .addKdoc("""DSL for creating views and settings their attributes.
                |This file has been generated by
                |{@code gradle $name}
                |${model.javadocContains}.
                |Please, don't edit it manually unless for debugging.""".trimMargin())
            .addModifiers(KModifier.PUBLIC)
            .addSuperinterface(ANVIL.nestedClass("AttributeSetter").parameterizedBy(ANY_N))
            .addFunction(setterFunction)
            .build()

        val attr = MemberName(PACKAGE, "attr")
        val bind = MemberName(PACKAGE, "bind")
        val v = MemberName(PACKAGE, "v")

        model.views.forEach { view ->
            val viewName = view.name
            val scopeType = ClassName(model.packageName, "${viewName}Scope")

            val viewType = view.starProjectedType

            val methods = view.attrs
                .map {
                    FunSpec.builder(it.name)
                        .addParameter("arg", it.type.argType.copy(nullable = it.isNullable))
                        .returns(UNIT)
                        .addCode(CodeBlock.of("return %M(%S, arg)", attr, it.name))
                        .build()
                }

            fileSpec.addFunction(FunSpec.builder(viewName[0].toLowerCase() + viewName.substring(1))
                .addParameter(
                    ParameterSpec.builder(
                        "configure",
                        LambdaTypeName.get(receiver = scopeType, returnType = UNIT))
                        .defaultValue("{}")
                        .build())
                .addCode(CodeBlock.of("return %M<%T>(configure.%M(%T))", v, viewType, bind, scopeType))
                .build())
            fileSpec.addType(TypeSpec.classBuilder(scopeType)
                .addModifiers(KModifier.PUBLIC, KModifier.ABSTRACT)
                .also {
                    val superType = view.superType
                    if(superType != null) {
                        it.superclass(ClassName(model.packageName, "${superType.name}Scope"))
                    } else {
                        it.superclass(ClassName(PACKAGE, ROOT_VIEW_SCOPE))
                    }
                }
                .addType(
                    TypeSpec.companionObjectBuilder()
                        .superclass(scopeType)
                        .addInitializerBlock(buildCodeBlock {
                            add("%T.registerAttributeSetter(%N)\n", ANVIL, setterObject)
                            if(model.manualSetter != null) {
                                add("Anvil.registerAttributeSetter(%M)\n", model.manualSetter)
                            }
                        })
                        .build()
                )
                .addFunctions(methods)
                .build())
        }

        fileSpec
            .addType(setterObject)
            .addAnnotation(AnnotationSpec.builder(Suppress::class)
                .addMember("\"DEPRECATION\", \"UNCHECKED_CAST\", \"MemberVisibilityCanBePrivate\", \"unused\"")
                .useSiteTarget(AnnotationSpec.UseSiteTarget.FILE)
                .build())
            .build()
            .writeTo(outputDirectory.also { it.mkdirs() })
    }

    private fun AttrModel.buildListener(): CodeBlock {
        val viewClass = owner.plainType.toString()

        val body = buildCodeBlock {
            if(type.isSamLike) {
                add("arg as %T\n", type.argType.copy(nullable = isNullable))
            }
            if (type.isSamLike && type.isInterface) {
                val function = type.functions.first()
                val args = function.argsString

                beginControlFlow("v.$setterName { $args ->")
                add(function.buildListenerCode(putReturn = false, functionalType = true))
                endControlFlow()
            } else {
                val listener = TypeSpec.anonymousClassBuilder().apply {
                    if (type.isInterface) {
                        addSuperinterface(type.plainType)
                    } else {
                        superclass(type.plainType)
                    }
                    type.functions
                        .map { it.buildListenerFunction(functionalType = type.isSamLike) }
                        .forEach { addFunction(it) }
                }.build()
                addStatement("v.$setterName(%L)", listener)
            }
        }

        return buildCodeBlock {
            val checkedType = if (type.isSamLike) {
                FUNCTION_STAR
            } else {
                type.plainType
            }

            if (viewClass == VIEW_CNAME) {
                // @formatter:off
                beginControlFlow("arg == null ->")
                    addStatement("v.$setterName(null as? %T?)", type.plainType)
                    addStatement("true")
                endControlFlow()
                beginControlFlow("arg is %T ->", checkedType)
                    add(body)
                    addStatement("true")
                endControlFlow()
                // @formatter:on
            } else {
                val v = owner.parametrizedType?.let { "(v as $it)" } ?: "v"
                // @formatter:off
                beginControlFlow("v is %T -> when", owner.starProjectedType)
                    beginControlFlow("arg == null ->")
                        addStatement("$v.$setterName(null as? %T)", type.plainType.copy(nullable = true))
                        addStatement("true")
                    endControlFlow()
                    beginControlFlow("arg is %T ->", checkedType)
                        add(body)
                        addStatement("true")
                    endControlFlow()
                    addStatement("else -> false")
                endControlFlow()
                // @formatter:on
            }
        }
    }

    private fun FunctionModel.buildListenerFunction(functionalType: Boolean): FunSpec {
        return FunSpec.builder(name)
            .addModifiers(KModifier.PUBLIC, KModifier.OVERRIDE)
            .returns(returnType)
            .addParameters(parameters.map(ParameterModel::toParameterSpec))
            .addCode(buildListenerCode(putReturn = true, functionalType = functionalType))
            .build()
    }

    private fun FunctionModel.buildListenerCode(putReturn: Boolean, functionalType: Boolean): CodeBlock = buildCodeBlock {
        if(putReturn) {
            add("return ")
        }
        // TODO this can blow up if listener method has method named "arg"
        add("arg")
        if(!functionalType) {
            add(".%L", name)
        }
        add("($argsString).alsoÂ·{ %T.render() }\n", ANVIL)
    }

    private fun AttrModel.buildSetter(): CodeBlock {
        val viewClass = owner.plainType.toString()

        val argAsParam = when {
            isVarArg -> "*arg"
            isNullable || isArray -> "arg as %T"
            else -> "arg"
        }

        // TODO check if getter is present and if so, use property assignment, else use setter call
        return buildCodeBlock {
            if (viewClass == VIEW_CNAME) {
                beginControlFlow("arg is %T ->", type.starProjectedType.copy(nullable = isNullable))
                addStatement("v.$setterName($argAsParam)", type.parametrizedType)
                addStatement("true")
                endControlFlow()
            } else {
                val v = owner.parametrizedType?.let { "(v as $it)" } ?: "v"

                beginControlFlow(
                   "v is %T && arg is %T ->",
                    owner.starProjectedType,
                    type.starProjectedType.copy(nullable = isNullable)
                )
                addStatement("$v.$setterName($argAsParam)", type.parametrizedType)
                addStatement("true")
                endControlFlow()
            }
        }
    }
}
